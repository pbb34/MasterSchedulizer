package ParserPackage;

import java.util.*;

import POSPackage.Course;
import POSPackage.POS;

public class CourseLoader {
	private CSVParser csvParser;
	private String csvFilepath;
	
	// TODO update field ints to corresponding field based on the csv document
	
	private final int subjectCodeField = 0;
	private final int courseNumField = 1;
	private final int courseTitleField = 2;
	private final int creditsField = 3;
	private final int preReqsField = 4;
	private final int coReqsField = 5;
	private final int termsOfferedField = 6;
	private final int termTakenField = 7;
	
	public CourseLoader() {
		// A knew courseLoader can be created for adding preReqs and coReqs
		// It requires no filepath and no parser
		this.csvFilepath = null;
		this.csvParser = null;
	}
	
	public CourseLoader(String fp) {
		this.csvFilepath = fp;
		this.csvParser = new CSVParser(this.csvFilepath);
	}
	
	private String getSubjectCode() {
		// TODO get subject code field using csvParser
		String sc = csvParser.getField(subjectCodeField);
		return sc;
	}

	private String getCourseNum() {
		String cn = csvParser.getField(courseNumField);
		return cn;
	}
	
	private String getCourseTitle() {
		String ct = csvParser.getField(courseTitleField);
		return ct;
	}
	
	private Double getCredits() {
		Double cre = Double.parseDouble((csvParser.getField(creditsField)));
		return cre;
	}
	
	//----------------------------- Finding PreReqs ----------------------------- 
	/*
	 * The strategy for this depends on the csv file being in order (meaning classes taken previously are listed first).
	 * Getting the prereqs must return an array of Course objects, but we can't possibly put all of the information required
	 * into the csv itself.
	 * What we can do is look up the course that has already been loaded into the POS and just use its information for the list of
	 * prereq courses.
	 * 
	 * First we get the list of names given to us in the csv file.
	 * Then we call findCourse from the plan of study which returns the course with the name matching the input string.
	 * After that the courses are put into a list and returned.
	 * 
	 * What this doesn't handle is the case where a student has a class on their schedule and they don't have the prereq.
	 * In theory this can never happen because the csv file is generated by save (and they wouldn't be able to get to save if their POS was invalid)
	 * we should still test for it in the future though.
	 */
	
	private String getPreReqField() {
		return csvParser.getField(preReqsField);
	}
	
	private ArrayList<String> splitPreReqField() {
		String rawLine = getPreReqField();
		ArrayList<String> preReqs = new ArrayList<String>(Arrays.asList(rawLine.split(" ")));
		return preReqs;
	}
	
	private ArrayList<ArrayList<Course>> getPreReqs(String preReqStr, Course course) {
		ArrayList<ArrayList<Course>> preReqs = new ArrayList<ArrayList<Course>>();
		ArrayList<String> tokens = new ArrayList<String>(Arrays.asList(preReqStr.split(" ")));
		// Keep track of the previous course index and the previous operator to handle Course
		int previousCourseIndex = 0;
		int numOperators = 0;
		String previousOperator = "and";
		
		// Iterate through tokens to add Courses to POS
		for(int i = 0; i < tokens.size(); i++) {
			// Every even element is a Course name
			if(i%2 == 0) {
				previousCourseIndex = preReqs.size() - 1;
				if(previousOperator.equals("and")) {
					// If the preReq token is empty, skip it
					if(tokens.get(i).equals("")) {
						continue;
					}
					// For AND, add a new ArrayList of courses to the PreReq list
					ArrayList<Course> temp = new ArrayList<Course>();
					String [] courseSplit = tokens.get(i).split("(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)");
					
					// If the course string doesnt include a subject code and a course num, skip it
					if(courseSplit.length != 2) {
						System.out.println(course.getCourseName() + "-> ");
						System.out.println("Couldnt find prereq " + tokens.get(i));
						continue;
					}
					
					Course tempPreReq = TMSMasterList.findCourse(courseSplit[0], courseSplit[1]);
					
					// If the course cannot be found in the masterlist, skip it
					if(tempPreReq == null) {
						System.out.println(course.getCourseName() + "-> ");
						System.out.println("Couldnt find prereq " + tokens.get(i));
						continue;
					}
					
					temp.add(tempPreReq);
					preReqs.add(temp);
					//previousCourseIndex = i - numOperators;
				}
				if(previousOperator.equals("or")) {
					// For OR, get the list which the previous course was stored in and add the new course
					// to that list
					
					String [] courseSplit = tokens.get(i).split("(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)");
					
					// If the course string doesnt include a subject code and a course num, skip it
					if(courseSplit.length != 2) {
						System.out.println(course.getCourseName() + "-> ");
						System.out.println("Couldnt find prereq " + tokens.get(i));
						continue;
					}
					
					Course tempPreReq = TMSMasterList.findCourse(courseSplit[0], courseSplit[1]);
					
					// If the course cannot be found in the masterlist, skip it
					if(tempPreReq == null) {
						System.out.println(course.getCourseName() + "-> ");

						System.out.println("Couldnt find prereq " + tokens.get(i));
						continue;
					}
			
					// If the program couldn't find a course (or skipped for any reason)
					// The previousCourseIndex may not contain a list yet
					/*
					if(preReqs.size() <= previousCourseIndex) {
						preReqs.add(new ArrayList<Course>(Arrays.asList(tempPreReq)));
					} else {
						preReqs.get(previousCourseIndex).add(tempPreReq);
					}
					*/
					if(previousCourseIndex < 0 || preReqs.get(previousCourseIndex) == null) {
						preReqs.add(new ArrayList<Course>(Arrays.asList(tempPreReq)));
					} else {
						preReqs.get(previousCourseIndex).add(tempPreReq);
					}
				}
			} else {
				// Every odd element is a logical operator
				previousOperator = tokens.get(i);
				numOperators++;
			}
		}
		return preReqs;
	}

	private String getCoReqField() {
		return csvParser.getField(coReqsField);
	}
	
	private ArrayList<Course> getCoReqs(String coReqStr) {
		ArrayList<Course> coReqs = new ArrayList<Course>();
		ArrayList<String> tokens = new ArrayList<String>(Arrays.asList(coReqStr.split(" ")));
		String [] courseSplit;
		Course tempCoReq;
		for(String cString : tokens) {
			courseSplit = cString.split("(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)");
			if(courseSplit.length != 2) {
				continue;
			}
			tempCoReq = TMSMasterList.findCourse(courseSplit[0], courseSplit[1]);
			if(tempCoReq == null) {
				System.out.println("Couldnt find coreq " + cString);
			} else {
				coReqs.add(tempCoReq);
			}
		}
		return coReqs;
	}
	
	private String getTermsOffered() {
		String to = csvParser.getField(termsOfferedField);
		return to;
	}
	
	private String getTermTaken() {
		String tt = csvParser.getField(termTakenField);
		return tt;
	}
	
	public Course getCourse() {
		if(csvParser.getLine() != null) {
			Course course = new Course(this.getSubjectCode(), this.getCourseNum(), this.getCourseTitle(), this.getCredits());
			course.setPreReqStr(this.getPreReqField());
			course.setCoReqStr(this.getCoReqField());
			course.setTermsOffered(this.getTermsOffered());
			course.setTermTaken(this.getTermTaken());
			return course;
		} else {
			return null;	
		}
	}
	
	public ArrayList<Course> assignPreReqs(ArrayList<Course> courseList) {
		for(Course course : courseList) {
			course.setPreReqs(this.getPreReqs(course.getPreReqStr(), course));
		}
		return courseList;
	}
	
	public ArrayList<Course> assignCoReqs(ArrayList<Course> courseList) {
		for(Course course: courseList) {
			course.setCoReqs(this.getCoReqs(course.getCoReqStr()));
		}
		return courseList;
	}
	
	public ArrayList<Course> getCourses() {
		Course c = null;
		ArrayList<Course> courseList = new ArrayList<Course>();
		while((c = this.getCourse()) != null) {
			courseList.add(c);
		}
		// Putting this here doesnt seem to work
		// MASTERLIST doesnt have time to initialize?
		//courseList = this.assignPreReqs(courseList);
		return courseList;
	}
}
